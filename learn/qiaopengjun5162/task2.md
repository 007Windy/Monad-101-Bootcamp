# 第二章：Solidity 快速入门

## 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
3. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

## 二、选择题

1. 函数选择器(selector)的计算方法是：  ​B 函数名哈希的前4字节
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

2. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

## 三、简答题

1. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

### **1. `require`**

#### **触发条件**  

• **前置条件验证**：用于检查函数执行前的合法性条件，例如输入参数有效性、合约状态变量约束或外部调用结果验证。
• **失败表现**：条件为 `false` 时触发异常。

#### **使用场景**  

• 验证用户输入（如 `require(input < 20)`）。
• 检查外部合约响应（如 `require(external.send(amount))`）。
• 执行前状态验证（如 `require(balance >= amount)`）。

#### **Gas 处理**  

• **退还剩余 Gas**：失败时回滚状态，并退还未使用的 Gas。
• **成本优化**：支持自定义错误信息（如 `require(condition, "Error message")`），但字符串越长 Gas 消耗越高。

---

### **2. `assert`**

#### **触发条件**  

• **后置条件验证**：用于检查理论上不可能发生的代码逻辑错误，例如整数溢出、不变性（invariants）或合约状态一致性。
• **失败表现**：条件为 `false` 时触发异常，通常表示合约存在代码漏洞。

#### **使用场景**  

• 检查整数运算溢出（如 `c = a + b; assert(c >= b)`）。
• 验证合约不变量（如 `assert(this.balance == totalSupply)`）。
• 函数执行后状态验证（如 `assert(newState == expectedState)`）。

#### **Gas 处理**  

• **消耗所有 Gas**：失败时不会退还剩余 Gas，直接耗尽所有 Gas。
• **调试用途**：主要用于开发阶段检测内部逻辑错误，生产环境应减少使用。

---

### **3. `revert`**

#### **触发条件**  

• **主动触发异常**：无需条件判断，可直接通过 `revert()` 或 `revert("message")` 回滚状态。
• **灵活控制**：适用于复杂逻辑分支（如多层 `if-else` 结构）。

#### **使用场景**  

• 自定义错误处理（如 `revert InsufficientBalance(balance, amount)`）。
• 替代 `require` 处理复杂条件（如 `if (condition) { revert(); }`）。
• 在条件不满足时主动终止执行（如 `revert("Transaction failed")`）。

#### **Gas 处理**  

• **退还剩余 Gas**：与 `require` 类似，失败时退还未使用的 Gas。
• **成本优化**：使用自定义错误（`error` 类型）可显著减少 Gas 消耗。

---

### **总结对比**

| **特性**         | `require`                     | `assert`                     | `revert`                     |
|-------------------|-------------------------------|------------------------------|------------------------------|
| **触发时机**      | 前置条件检查                  | 后置逻辑验证                 | 主动终止执行                 |
| **Gas 处理**      | 退还剩余 Gas                  | 耗尽所有 Gas                 | 退还剩余 Gas                 |
| **适用场景**      | 输入验证、状态检查            | 代码逻辑错误检测             | 复杂条件分支、自定义错误     |
| **错误信息支持**  | 支持（但增加 Gas 成本）       | 不支持                       | 支持（推荐自定义错误）       |
| **推荐使用频率**  | 高频（函数开头）              | 低频（调试阶段）             | 中频（灵活场景）             |

---

1. **优先使用 `require`**：用于所有外部输入和状态的前置验证。
2. **限制 `assert` 使用**：仅在检测代码逻辑错误时使用（如溢出检查）。
3. **灵活应用 `revert`**：结合自定义错误类型优化复杂逻辑的 Gas 开销。

优先使用 require：在大多数情况下，require 是检查外部条件的最佳选择，Gas 效率高且支持错误信息。

谨慎使用 assert：仅在需要验证关键不变量或调试时使用，避免在生产环境中滥用，因为它会浪费 Gas。

灵活使用 revert：在复杂的控制流中，revert 提供了更高的灵活性和可读性。

2. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？
实际执行时会优先调用 B 合约的 foo() 函数。继承顺序规则：Solidity 使用 ​C3 线性化算法 确定多继承中的函数调用顺序。该算法会将继承列表中 ​后列出的合约视为更近的父级，因此合约 B（在 C is A, B 中位于后面）的优先级高于 A。继承顺序（C is A, B）决定了父合约的调用优先级，B 的优先级高于 A。**override 关键字的作用**：在合约 C 中，override(A, B) 明确表示该函数重写了 A 和 B 的 foo() 函数。虽然需要列出所有父合约，但继承顺序（而非 override 列表顺序）才是决定调用顺序的关键。

3. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

call：
风险：如果目标合约有恶意代码（例如通过 receive 函数重入调用发送者合约），可能耗尽 Gas 或窃取资金。

建议：使用时需结合“检查-效果-交互”模式（Checks-Effects-Interactions Pattern）或限制 Gas，例如：
solidity

(bool success, ) = addr.call{value: 1 ether, gas: 30000}("");
require(success, "Transfer failed");

适合需要灵活性或目标合约有复杂逻辑的场景。

transfer：
风险：2300 Gas 限制可能不足以让目标合约执行必要的逻辑（例如记录日志），导致转账失败。

建议：适用于发送 ETH 给外部账户（EOA）或简单合约，避免用于需要更多 Gas 的合约。

如果目标合约需要更多 Gas，建议改用 call。

transfer 更安全、简单，适合简单的 ETH 转账。

call 更灵活但风险更高，适合需要自定义逻辑或处理复杂交互的场景。
选择哪种方式取决于你的具体需求和安全考虑。
